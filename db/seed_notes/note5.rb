module Seeds
  class Note5
    def self.content
      <<~NOTECONTENT
        [Music] hey everyone uh I am jayes I work at 37 signals I'm I lead the mobile team uh there um and I'm a programmer primarily on the Android side as well um we uh uh well before we get into strata there's an important question I know some of you are asking so let's just get it out of the way right now did you seriously tease tease Strat and hotwire's launch years ago to get my hopes up and take a really really really really really really long time to finally launch and I've had to wonder what it is how it works and if I should care for so long yes and now that we have that out of the way I would love to tell you all about it so um a little bit of um I'll start high level before we get into the weeds um so the web as you all know the web is really great at a lot of things it's it's broadly accessible uh you can develop really fast prototype uh things really fast it's great at displaying server driven UI and uh your changes are really quick and easy to deploy if some of you are mobile developers you are very familiar with uh the long slow review processes being a painful part of the job native apps they are optimized for small screens you can have a really high fidelity experience uh you can take advantage of the platform apis and conventions Apple and Google have done a great job giving you really great uh platform apis that we all can use and you also get to use UI components for free more or less so 37 signals our apps are uh hybrid they're built on uh the turbo native libraries and our native we have two types of screens we have native screens and those just render UI from uh the from Json end points and when we've got a native screen we can control the entire screen everything is up to the native code um we can do anything we want we also have web view screens driven by Turbo and those uh display web content within a rectangle on the screen and that looks like this so um while we can decorate the uh web view with some native uh Chrome around the web view um there is a problem and that problem is there's a disconnect between the web view on the screen and the native uh shell and features of your application that you may want to deliver there's uh no easy way for the native app to know what's going on in the web view so for a long time we built our apps on uh the turbo libraries for a long time Bas camp and hay uh primarily and we knew we needed a way to communicate uh with the web View back to the native app and then from the Native app back to the web View and we went through several approaches and mistakes along the way one thing we did was we would package apps specific JavaScript within our native apps um to manipulate and query the web view Dom this is a really fragile approach um and it would break if we ever changed the web app uh which web app you know your web app May um you may change it really frequently and so this is this is a major problem when the only way to fix a bug is to ship a new app update and wait for review times the native apps also uh don't know when there are State changes in the web view Dom so um unless you're packaging very specific app domain knowledge within your native apps uh about your web view app um it's really difficult to know what's what's happening in the web view also uh at 37 signals we have a web team we've got web programmers and designers and then we have our mobile team we've got mobile programmers and designers and we uh work independently we do work together but we also work independently and um it was really difficult for web designers and programmers to know when changes to the web app would negatively impact the native apps so we knew we needed a solution to this long term um we had an approach in in base camp uh for a long time that we knew kind of worked but it wasn't great and um so we set out to create an approach um a framework that could solve these problems for us and um we knew we wanted to it to be a bridge between your web code and your native app code and we knew we wanted it to be a component based framework because um that was the way that we saw that we could scale as the web app and Native apps scaled um we could if things were componentized we could um uh cleanly separate the lines between different features we had some rules about what we wanted to um how we wanted to solve the problem one of them was um the the apps must not know anything about the Dom markup on the page uh the knowledge that the native app has should be completely divorced from the actual Dom in the web view the native app can't package any app specific JavaScript in the app uh the way the native and and web apps should communicate um together we use Json for this in St and the web app uh should be able to send State changes uh from the web view to the native app tell to inform it about changes and the native app should be able to reply back to uh State changes is back to the web and um the other thing we wanted to do was um as you if you have a turbo um Native app one of the things you'll realize is you want to launch a new feature and you have you can push that out and deploy your changes immediately on the web but it may take one two three a week uh to uh ship out your app update during that time um how do you transition from CL old clients to uh new clients and so strata is uses a uh optin opt-in uh component system where uh the behaviors change based on whether the native apps support certain components that the web app already knows about we also want to be able to bridge uh web UI to Native UI in clever ways we already had a um a lot of things that we were doing um uh on the base camp side and so we were building hey we knew we wanted to build even more sophisticated uh Native features that were um driven by the web app so all those things combined we spent some time and we developed strata we've been using it in Hay ever since hey launched in 2020 and it's a set of libraries across all the platforms uh to create fully native controls in your um hybrid mobile apps driven by the web what do I mean by driven by the web I mean your web app determines when and where Native controls uh show up in your native apps the native apps don't get to decide where Native control show up show up your web app actually can control that St leverages stimulus directly um so it gives you the the same power uh in your web components as you're familiar with uh with stimul stimulus all right so let's look at an example here's a screen in hey this is a screen to edit your profile nothing fancy here um if you notice at the bottom there's a save button um this is in the web view this is a web view screen one of the um you know in mobile apps it's quite common to have your submit buttons or save buttons or next buttons up in the top right um uh toolbar app bar area and um that's convenient for a few reasons this is an example of when you've got the virtual keyboard open uh you can no longer see the save changes button and so the user has to scroll there also like blank empty space up in the top right corner so let's improve it we're going to move the submit button to the top right of the app bar we're going to hide the submit button in the web View we're going to notify uh the web uh the native app will notify the web app when the native submit button is tapped and the uh web submit button will submit the form as if the user had tap the web view button directly so the web form let's say um this is you know stripped down to the basics so let's say you've got a web form element M with a uh submit input let's hook this up to strata and make a web component so the first thing we're going to do is we're going to add a data controller attribute just like you would do in stimulus we're going to uh tie that to it to a bridge form component and we're also going to set the button the submit Button as a target for uh the component so to create uh a web component for strata you're going to extend the bridge component class the bridge component class is itself an extension of a stimulus controller so you have all the same things in stimulus that you would have in a bridge component but the bridge component adds another layer of strata specific functionality that you can use one thing you need to do is give your component a name this is just a a plain text name that both the web app and Native app uh will agree on and it's uh used as an identifier between between the two we'll set up our Target for the submit button when the submit button is connected uh on the page we're going to do a few things here so the first thing um we'll do is we'll uh wrap the uh submit Buton Target in a bridge element the bridge element is a class that gives you some strata specific uh behaviors and features for um for strata for your web components um one of the things that you can do is you can easily set up titles for your uh elements and you can you can reuse your own uh web uh titles or you can uh come up with strata specific titles attributes for your um Native apps so for example the web app uh button says save changes if we wanted to just say save it'd be trivial to do that um with uh extra markup on your elements this is the this is where things get interesting um we are going to now send a message uh to the native app um and let's look at the different parameters here so um first we've got uh connect this is the name of the event that um we're going to send every message has an event name uh and this is something that your uh web web component and your native component are just going to agree on on the different types of events that they support the next parameter is data uh in Json format so we're going to pass along this name of the the submit title to the native app so it's the title of the of the the submit the third parameter is a call back it's a call back that will get triggered when the native component replies back to the the uh web component uh and back specifically back to this message that was that was that we're sending right now oh one thing uh if you look at what we're doing here when this when the native component replies back we are going to click the submit button on the form so um it's very simple here but the nice thing here is we're not changing anything about the way this form Works we're not changing uh validation we're not changing how it submits to the server anything like that all we're going to do is pretend that the user clicked thisit button um when in fact it was proxied through strata so let's look at the um Bridge message that is sent if your native app supports the form component let's break it down we've got an ID this is just autogenerated by strata on the on the website you don't need to really worry about it we got the name of the component which is form in this case got the name of the event which is connect and we got the data that sent along so you can see here we got the submit title uh and we've also got some metadata that gets passed along as well and this makes sure that we never send um or we always send the correct messages so the correct components on the correct screens so that's what this is used for here let's go to the native side so we're done we've already we're done with the website we've done everything we need to do for the web component uh I'm going to give an example here in Android I'll give an example on iOS later so you can see both so we're going to ex extend the bridge component class on the native side this is in cotlin we have to implement the on receive uh function here and and this is when the component receives messages for this component and um when the uh message event is connect we're going to handle that and um here's what it will look like to set that up so first we're going to get the data from the message this will be the a deserialized Json and you can look down below right here at the bottom lines 23 through 26 this is a a standard way of setting up uh deserializing data uh on in cotlin uh we're going to create uh the native toolbar button and place it in the toolbar um I've got this for the sake of the presentation I don't have all the code here but if you want to look at our turbo native demo apps we've got all this code and more uh as examples so we put our we created our native button we put it in the toolbar we're going to set the text as the the uh title coming in from the data in the message and then we're going to set an onclick listener for that button then what we're going to do is when the user Taps the button we're going to reply back to the connect uh event message that was last received and um we can Al you can also optionally pass data along when you reply but we don't need to do that here all we need to say is uh the user uh did the thing that we need to um and we're going to reply back to the connect message so connecting the dots there are there's some initial setup to do on the native side um initializing the bridge with the web viiew instance updating the web view user agent screen so the backend knows what components are uh supported um we're going to delegate the turbo life cycle events um to a bridge delegate class and register the form component all this stuff is in the quick is in the uh quick start guid for strata iOS and EST strata Android libraries um this is onetime setup stuff that you need to use to set up and uh we'll probably improve this process a little bit um in coming updates all right so we've built the web component we built the native component um how do those things connect uh on um in your web app so strata um both the native app the native app declares what uh components it supports and and the web can look at and see and change behaviors based on what uh components are supported so one thing that's done um Str does automatically for you is it'll update your uh document element in your web app with both the platform that's uh being used uh for um the strata bridge and the supported components so that will always live on the document ele element and the strata web library takes care of that for you uh we also um recommend updating your user agent to include the supportive Bridge components we've got help our methods to make that easy for you to do uh this way your backend can know uh what what components are supported if you ever want to make uh do conditional Logic on the back end all right so back to the example what are we missing the button is up in the top right corner if we tap it it will Um send a me it will reply to that the message and the web will click the submit button and submit the form just like it always did but you can see here we've also got the uh web button still there there's an easy way to fix this we're going to use the registered Bridge component to uh have scope CSS here so for any uh it would look just like this for any submit button inside of a a bridge Form controller whenever uh a Bridge uh whenever the form component is supported in the native app we will hide the submit button and So then whenever uh this works both forward and backwards compatible so if you launch a new feature and you've got uh a web form but the native app doesn't support the form component yet you'll still see the web button if your native app is updated support it we'll show the native one instead so then it'll look like this so the flow of events um whenever uh you've got a bridge component that connects on your page and you send an event it will send it through to the bridge there's a bridge class on the web Bridge class on the native side it's the glue that strata um creates between the two and it will end up the message will end up in your Bridge component when the native side replies back to the original message it will just go in reverse so it will go from your native Bridge component back through the bridge and uh to your web Bridge component this is a nice example of progressive enhancement you can uh start out with purely web uh everything in your web View and layer on uh Native features as you go one of the cool things here is you've already built your web component you've built your uh Native component those are um cleanly separated from your app features so all you have to do now is any form in your web app you can add your uh Bridge Form controller attribute and add your uh your submit Target and you're good it'll work in any screen across your entire app uh web and Native let's look at a more advanced example this is a screen that we have in Hay uh this um um menu is completely driven by the web the purple menu here doesn't know anything about any of the features that it's showing here um it only knows that it's displaying uh it only knows it's displaying a list of items um with different attributes even the icons come from the web so we pass along icon URLs and that's driven by the web as well um this specific example for the sake of the presentation it's a little um too much code to show but we have a example in the turbo native demo apps that's uh a simplified version here that I'll go through so on this um on this uh screen you can see this this open menu button this will open up a menu that looks like this if you don't have strata at all one thing you can notice here um it's got a nice overlay window uh backdrop however it can't stretch across the um the native uh as parts of the app it also can't block input from the uh rest of the Native part of the app so you could tap the back button for example and um you're not able to actually block the user input it doesn't support gestures or anything like that so let's turn this into a strata component and turn it into something that looks like this so let's build a web menu first we've got a um we've just got a div we've got um a data controller you notice here we've got two controllers here one is a menu controller um and this is actually driving the functionality on the website for the web menu uh that that exists and we've also got a a bridge menu controller uh for the brid Bridge component uh that we've got as well both of these can work together um and you can layer on even if you're already using a stimulus controller for your web features you can layer on a bridge uh a bridge component and those can work together and I'll show you how that works so um one of the things here you'll notice whenever one of the web menu buttons is clicked uh it will uh show it will call um before the bridge component it will show the uh menu show function we're going to put the uh click event for the bridge component here first to give it an opportunity to show uh a bridge um uh menu component if if it makes sense um if the native app supports it we've also we're going to set up the uh a title for the menu so this is uh just says select an option so we're going to set up a target for that and then whenever a button is is clicked on in the um menu we're going to call the uh menu item selected uh function there which uh will work uh in the menu controller um we've also got a uh menu Target item um this is an item for the menu controller and for the bridge controller we're also going to give an item Target as well so building the web component we're going to give it the uh name of menu and we're going to give uh set up the targets the title of the menu and then the items uh in the menu as well we got the the show uh function here which will be called um by the um attributes that we set up on the previous slide and um what we're going to do here is we're going to say if the if this is enabled so this means if the uh Native app supports if this component's enabled and the web app or sorry the native app supports the menu component we're going to uh stop uh the propagation of that event and it will no longer bubble up uh to the menu uh the regular menu controller and then we're going to notify the web app or sorry we're going to notify the native app that uh it needs to display a menu we's look at how that's set up so we're going to um wrap the title Target in a bridge element to get it get its title we're going to make the menu items uh into Json uh I don't have that code here but it's very simple it's in the uh demo app that we've got then we're going to send a message so we're going to send a display event message to the native app we're going to pass along the data with title and all the items in the menu and then we're going to uh have a set up a call back here whenever the uh a menu item is is uh tapped in the native app we're going to extract the selected index from the reply message that was passed from the Native component and then we're going to uh use that selected index to get the target of the button that was tapped on the native side and then what we're going to do is we're just going to click that so um once we click that the menu controller that you've already set up on the for your uh web app will get invoked and um uh that's all you need all right so the we set at the web component it's going to pass a message to the native app it's going to have an ID it's going to have the menu component name it's going to have the display event it's going to have a title for the menu and then it's also going to have all the items that are in in the menu you can see here it's got uh the title and an index the index is the index of the um button um in the list of buttons that you're displaying now let's build a native component so this is Swift on the iOS side we're going to uh extend the bridge component class we're going to set up the the name of the component which is menu which matches the web web component we're going to uh implement the on receive function here whenever we receive messages from the web and then we're going to handle the display event so we're going to get the data from the message and we are going to show um the alert uh sheet uh here so um I haven't I didn't put all the code here to actually implement the sheet but it's in our demo app if you want to look at it um we're going to present that sheet and when an item is tapped uh this on item selected function will get called and then we are going to reply back to the message uh the display event message with uh data unlike what we did with the submit button one this is actually passing data back to the web so we're going to pass along the selected index of the item that was tapped and that will return a message back to the web it'll look like this it will have this the same component and event names that it did before and it will pass along data with the selected index so if you tap the first item it'll pass along selected index zero and going back to the web component it will uh will use that selected index to click the original button so um we have a lot of examples in Hay that we've built we've built components to um if you're viewing an email we've got a floating action bar that has buttons that can show menus um we've got uh a feature in hey to highlight text and um create clips of content um as you highlight text it will uh will show native UI there we've got a flash message component which turns your web flash messages into uh Native uh UI so that you can take advantage of the platform form um conventions there we've got a nav button component this is a component that lets us arbitrarily display small icon buttons in our uh app bars at the top of at the tops of the app we got an over overflow menu component this uh component lets lets us display a three dot menu in the uh top right of the app and then display a menu from there for uh lesser common actions in the app we've got a page component this one's interesting um the page component actually connects on every single page uh in in the web app and let's just do some nice things uh on some pages for example we um instead of showing the title of your page in the in the top app bar we'll show it in large styled text in the web View and as you scroll uh the page and the page Scrolls away we will uh uh move animate the title into the top app bar and then when you scroll back down in the web view page um it will remove the title from the app bar and then you can see it back in the web view again and that's an example of um uh a component that um might be quite challenging to pull off uh without strata but we can easily um pass those events uh to the native apps and and respond accordingly we've got a print component so um you can print emails for example on hey um this lets us uh there's limitations in the web view apis on mobile and um what the web app would be able to do so this lets us natively print your emails uh driven by the web app and then we've got a tricks component which lets us set up uh tricks toolbars and all the actions and uh have native UI we've got a lot of examples that we've build up and we're going to work on contining to add more demo examples um on the library side as well and uh that is all I have so thank you so [Applause] [Music] much
      NOTECONTENT
    end
  end
end
